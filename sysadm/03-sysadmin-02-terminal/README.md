# Домашнее задание к занятию "Работа в терминале. Лекция 2"

### Цель задания

В результате выполнения этого задания вы:

1. Ознакомитесь с возможностями некоторых команд (grep, wc), что позволит в дальнейшем обращать внимание на схожие
   особенности команд.
2. Попрактикуетесь с перенаправлением потоков ввода, вывода, ошибок, что позволит грамотно использовать функционал в
   скриптах.
3. Поработаете с файловой системой /proc как примером размещения информации о процессах.

### Инструменты/ дополнительные материалы, которые пригодятся для выполнения задания

[Статья с примерами перенаправлений в Bash и работы с файловыми дескрипторами](https://wiki.bash-hackers.org/howto/redirection_tutorial)


------

## Задание

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей, если
   считаете, что она могла бы быть другого типа.
   `cd` – внутренняя команда

```bash
vagrant@vagrant:~$ type cd
cd is a shell builtin
  ```

2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?

    <details>
    <summary>Подсказка</summary>

   `man grep` поможет в ответе на этот вопрос.

    </details>

   Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах
   использования pipe.

   `grep <some_string> <some_file> -c`

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

- процесс` /sbin/init`

```bash
   vagrant@vagrant:~$ ps aux
   USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
   root 1 0.0 1.1 167404 11532 ? Ss Sep02 0:06 /sbin/init
   ```

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

`ls -la /dir1 2>/dev/pts/1`

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий
   пример.

```bash
vagrant@vagrant:~/test$ cat 1.txt
This is test message.
vagrant@vagrant:~/test$ cat < 1.txt > output.txt
vagrant@vagrant:~/test$ cat output.txt
This is test message.
```

6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы
   наблюдать выводимые данные?

   Да. `echo "Hello World!" > /dev/tty`


7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`?
   Почему так происходит?

`bash 5>&1` - создаем новый дескриптор 5 и перенаправляем его в STDOUT

`echo netology > /proc/$$/fd/5` - перенаправляем результат команды в дескриптор 5.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение
   stdout на pty?  
   Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.

Получится. Для этого нужно "поменять местами STDOUT и STDERR", создав, например, новый дескриптор 5 и использовать его
как промежуточный

`5>&1 1>&2 2>&5 `. Данное выражение выполнить после команды и перед pipe.

9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

Показывает переменные окружения для процесса, под которым выполняется текущая оболочка bash ($$). Аналогичный вывод
у команды `printenv`.

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

`/proc/[pid]/cmdline `- этот файл содержит полную командную строку запуска процесса, кроме тех процессов, что
полностью ушли в своппинг, а также тех, что превратились в зомби. В этих двух случаях в файле ничего нет, то есть
чтение этого файла вернет 0 символов. Аргументы командной строки в этом файле указаны как список строк, каждая из
которых завешается нулевым символом, с добавочным нулевым байтом после последней строки.

`/proc/[pid]/cmdline` - является символьной ссылкой, содержащей фактическое полное имя выполняемого файла. Символьная
ссылка exe может использоваться обычным образом - при попытке открыть `exe` будет открыт исполняемый файл.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

`sse4_2`

```bash
    vagrant@vagrant:~$ grep sse /proc/cpuinfo
    fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx
    rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1
    sse4_2 x2apic popcnt aes xsave avx hypervisor lahf_lm pti md_clear flush_l1d
```

12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty.  
    Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2.  
    Однако:

     ```bash
     vagrant@netology1:~$ ssh localhost 'tty'
     not a tty
     ```
    Почитайте, почему так происходит, и как изменить поведение.

По умолчанию при запуске команды через SSH не выделяется TTY. Если же не указывать команды, то TTY будет выдаваться, так
как предполагается, что будет запущен сеанс оболочки.
Для принудительного использования необходимо указать ключ -t.

```bash    
vagrant@vagrant:~$ ssh -t localhost tty
vagrant@localhost's password:
    /dev/pts/1
    Connection to localhost closed.
```

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это,
    воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в
    обычной SSH-сессии.
reptyr -s 3375

```bash
    vagrant@vagrant:~$ sudo nano /proc/sys/kernel/yama/ptrace_scope
    vagrant@vagrant:~$ reptyr -s 3375
    [-] Timed out waiting for child stop.
    Hangup
    vagrant@vagrant:~$ screen -S 3375
    [screen is terminating]
    vagrant@vagrant:~$
```

14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как
    перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной
    проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте, что делает команда `tee` и
    почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

Команда `tee` делает вывод одновременно и в файл, указанный в качестве параметра, и в `stdout`.
В данном примере команда получает вывод из `stdin`, перенаправленный через `pipe` от `stdout` команды `echo`,
и так как команда запущена от `sudo`, соответственно имеет права на запись в файл.
----
